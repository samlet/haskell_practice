-- toplevel
-- collections

let numbers = [1,2,3,4]
let truths  = [True, False, False]
let strings = ["here", "are", "some", "strings"]

-- 列表元素必须是同一类型。因此， [42, "life, universe and everything else"] 不是一个正确的列表，因为它包含了两种不同类型的元素，也就分别是整型和字符串型。而 [12, 80] 或者， ["beer", "sandwiches"] 都是合法的列表，因为他们都是单一类型的。

-- 附加(Cons)

1:0:numbers
-- [1,0,1,2,3,4]
2:1:0:numbers
-- [2,1,0,1,2,3,4]
5:4:3:2:1:0:numbers
-- [5,4,3,2,1,0,1,2,3,4]

-- 列表可以包含列表

let listOfLists = [[1,2],[3,4],[5,6]] 
listOfLists
-- [[1,2],[3,4],[5,6]]

-- 一些元组

(True, 1)
("Hello world", False)
(4, 5, "Six", True, 'b')

-- fst和snd，它们分别“投影”出一个对中的第一和第二个元素（用数学语言来说，从结构体中取出数据的函数叫做“投影”（Projection））。让我们来看一些例子：

fst (2, 5)	-- 2
fst (True, "boo") -- True
snd (5, "Hello") -- "Hello"

let first (x, y) = x
first (3, True) 

-- 我们可以像在列表中储存列表一样来操作元组。元组也是数据，所以你可以在元组中储存元组（嵌套在元组中直到任意复杂的级别）。同样，你也可以创建元组组成的列表，列表组成的元组，以下例子的每一行分别表达了一中不同的组合方法。
((2,3), True)
((2,3), [2,3])
[(1,2), (3,4), (5,6)]

-- 将两个 List 合并是很常见的操作，这可以通过 ++ 运算子实现。
[1,2,3,4] ++ [9,10,11,12]  
-- 字串实际上就是一组字符的 List，"Hello" 只是 ['h','e','l','l','o'] 的语法糖而已。所以我们可以使用处理 List 的函数来对字串进行操作。 
"hello" ++ " " ++ "world"  
['w','o'] ++ ['o','t']  

-- 用 : 运算子往一个 List 前端插入元素会是更好的选择。
'A':" SMALL CAT"  
5:[1,2,3,4,5] 

-- 若是要按照索引取得 List 中的元素，可以使用 !! 运算子，索引的下标为 0。
"Steve Buscemi" !! 6  
-- 'B'  
[9.4,33.2,96.2,11.2,23.25] !! 1  
-- 33.2

-- List 同样也可以用来装 List，甚至是 List 的 List 的 List
let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
[6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
b !! 2
[1,2,2,3,4]

-- 当 List 内装有可比较的元素时，使用 > 和 >= 可以比较 List 的大小。它会先比较第一个元素，若它们的值相等，则比较下一个，以此类推。
[3,2,1] > [2,1,0]  
True  
[3,2,1] > [2,10,100]  
True  
[3,4,2] > [3,4]  
True  
[3,4,2] > [2,4]  
True  
[3,4,2] == [3,4,2]  
True

-- head 返回一个 List 的头部，也就是 List 的首个元素。
head [5,4,3,2,1] 
5
-- tail 返回一个 List 的尾部，也就是 List 除去头部之后的部分。
tail [5,4,3,2,1]  
[4,3,2,1]
-- last 返回一个 List 的最后一个元素。
last [5,4,3,2,1]  
1
-- init 返回一个 List 除去最后一个元素的部分。
init [5,4,3,2,1]
[5,4,3,2]

-- length 返回一个 List 的长度。
length [5,4,3,2,1]  
5
-- null 检查一个 List 是否为空。如果是，则返回 True，否则返回 False。应当避免使用 xs==[] 之类的语句来判断 List 是否为空，使用 null 会更好。
null [1,2,3]  
False  
null []  
True
-- reverse 将一个 List 反转:
reverse [5,4,3,2,1]  
[1,2,3,4,5]
-- take 返回一个 List 的前几个元素，看：
take 3 [5,4,3,2,1]  
[5,4,3]  
take 1 [3,9,3]  
[3]  
take 5 [1,2]  
[1,2]  
take 0 [6,6,6] 
[]
-- 如上，若是图取超过 List 长度的元素个数，只能得到原 List。若 take 0 个元素，则会得到一个空 List！ drop 与 take 的用法大体相同，它会删除一个 List 中的前几个元素。
drop 3 [8,4,2,1,5,6]  
[1,5,6]  
drop 0 [1,2,3,4]  
[1,2,3,4]  
drop 100 [1,2,3,4]  
[]
-- maximum 返回一个 List 中最大的那个元素。minimun 返回最小的。
minimum [8,4,2,1,5,6]  
1  
maximum [1,9,2,3,4]  
9
-- sum 返回一个 List 中所有元素的和。product 返回一个 List 中所有元素的积。
sum [5,2,1,6,3,2,5,7]  
31  
product [6,2,1,2]  
24  
product [1,2,5,6,7,9,2,0]  
0
-- elem 判断一个元素是否在包含于一个 List，通常以中缀函数的形式调用它。
4 `elem` [3,4,5,6]  
True  
10 `elem` [3,4,5,6]  
False

-- Tuple ------------------
-- 我们要表示一个人的名字与年 龄，可以使用这样的 Tuple:
("Christopher", "Walken", 55)

-- fst 返回一个序对的首项。
fst (8,11)
8
fst ("Wow", False)
"Wow"
-- snd 返回序对的尾项。
snd (8,11)
11
snd ("Wow", False)
False
-- *Note*：这两个函数仅对序对有效，而不能应用于三元组，四元组和五元组之上。

-- 有个函数很 cool，它就是 zip。它可以用来生成一组序对 (Pair) 的 List。它取两个 List，然后将它们交叉配对，形成一组序对的 List。它很简单，却很实用，尤其是你需要组合或是遍历两个 List 时。如下是个例子：
zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
zip [1 .. 5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
-- 它把元素配对并返回一个新的 List。第一个元素配第一个，第二个元素配第二个..以此类推。注意，由于序对中可以含有不同的型别，zip 函数可能会将不同型别的序对组合在一起。若是两个不同长度的 List 会怎么样？
zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im"),(3,"a"),(2,"turtle")]
-- 较长的那个会在中间断开，去匹配较短的那个。由于 Haskell 是惰性的，使用 zip 同时处理有限和无限的 List 也是可以的：
zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]













